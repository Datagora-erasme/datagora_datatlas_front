{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udf0d DatAtlas DatAtlas allows you to create a map of the territory on the fly by embedding data from different sources: open sourced data but also crowdsourced data All infos about the front and the back are stored here React Front using kepler.gl Front Setup more infos here WIP Using docker The easiest way to launch datAtlas can be by using docker-compose Clone the repo https://github.com/datatlas-erasme/front.git Copy env.example and rename it into .env Put your mapbox token in the .env file Launch DatAtlas docker-compose up Now you can access the server trough http://localhost:5007 Manually Requirements - nodejs - a mapbox api access token Clone the repo https://github.com/datatlas-erasme/front.git Copy env.example and rename it into .env Put your mapbox token in the .env file [WIP TODO] - Change the backend var URl Install and start npm npm install npm start Back Setup more infos here WIP How does datatlas work [WIP] Datatlas is made of a front and a back The front is a keplergl surcharged with a styling and theme management [WIP] The back is here to give the front the styling,dataset configuration and urls He is also able to handle notion tables he converts into a readable keplergl json format (and soon other unconventionnal data sources / unconventionnal => no geojson ) The front needs the back server to know : - wich data layers he needs to load - wich name he has (ex: Datatlas-Industries) - wich optionnal button he has (ex: crowdsourcing buttons to add a new point on the map) - how are the layers and filters configured by default two API routes are used for it : GET api/ more infos on routes here Production DatAtlas is not ready for production yet","title":"Home"},{"location":"#datatlas","text":"DatAtlas allows you to create a map of the territory on the fly by embedding data from different sources: open sourced data but also crowdsourced data All infos about the front and the back are stored here React Front using kepler.gl","title":"\ud83c\udf0d DatAtlas"},{"location":"#front-setup","text":"more infos here WIP","title":"Front Setup"},{"location":"#using-docker","text":"The easiest way to launch datAtlas can be by using docker-compose Clone the repo https://github.com/datatlas-erasme/front.git Copy env.example and rename it into .env Put your mapbox token in the .env file Launch DatAtlas docker-compose up Now you can access the server trough http://localhost:5007","title":"Using docker"},{"location":"#manually","text":"Requirements - nodejs - a mapbox api access token Clone the repo https://github.com/datatlas-erasme/front.git Copy env.example and rename it into .env Put your mapbox token in the .env file [WIP TODO] - Change the backend var URl Install and start npm npm install npm start","title":"Manually"},{"location":"#back-setup","text":"more infos here WIP","title":"Back Setup"},{"location":"#how-does-datatlas-work-wip","text":"Datatlas is made of a front and a back The front is a keplergl surcharged with a styling and theme management [WIP] The back is here to give the front the styling,dataset configuration and urls He is also able to handle notion tables he converts into a readable keplergl json format (and soon other unconventionnal data sources / unconventionnal => no geojson ) The front needs the back server to know : - wich data layers he needs to load - wich name he has (ex: Datatlas-Industries) - wich optionnal button he has (ex: crowdsourcing buttons to add a new point on the map) - how are the layers and filters configured by default two API routes are used for it : GET api/ more infos on routes here","title":"How does datatlas work [WIP]"},{"location":"#production","text":"DatAtlas is not ready for production yet","title":"Production"},{"location":"back/","text":"Backend API Routes Test backend URL /api/data/test/ Method GET Success Response: Returns test string Code : 200 Content : test Get the kepler configuration URL /api/conf/kepler Method GET Success Response: Returns a kepler.gl formated json of the dataset Code : 200 Content : { \"version\": \"v1\", \"config\": { \"visState\": {}, \"mapState\": {}, \"mapStyle\": {} } } Get the instance configuration URL /api/conf/kepler Method GET Success Response: Returns a kepler.gl formated json of the dataset Code : 200 Content : { \"siteTitle\": \"Instance Name\", \"mapboxToken\": \"mapboxToken\", \"defaultMapLocation\": { \"latitude\": 0, \"longitude\": 0, \"zoom\": 10 }, \"defaultMapBoxStyleUrl\": \"mapbox://styles/yourmapboxstyle\", \"modules\": { \"exportDataBtn\": true }, \"theme\": { \"filterSidePanel\": { \"buttonColorRange\": [ \"#dc7e6d\", \"#69b59d\", \"#c3c356\" ] } }, \"bottomRightButtons\": [ { \"text\": \"hey im a button\", \"url\": \"url\" }, { \"text\": \"hey im a button\", \"url\": \"url\" } ], \"layers\": [ { \"name\": \"layerName\", \"type\": \"notion\", \"url\": \"notionUrl\", \"id\": 0 }, { \"name\": \"GeoJson Data api\", \"type\": \"geojson\", \"url\": \"url\", \"id\": 1 } ] } Update the kepler configuration URL /api/conf/kepler Method POST Data Constrains The kepler json is created trough the kepler interface body: form-data key: configuration_kepler value: { \"version\": \"v1\", \"config\": { \"visState\": {}, \"mapState\": {}, \"mapStyle\": {} } } Success Response: Code : 200 Content : Update the instance configuration URL /api/conf/instance Method POST Data Constrains The kepler json is created trough the kepler interface body: form-data key: configuration_instance value: { \"siteTitle\": \"Instance Name\", \"mapboxToken\": \"mapboxToken\", \"defaultMapLocation\": { \"latitude\": 0, \"longitude\": 0, \"zoom\": 10 }, \"defaultMapBoxStyleUrl\": \"mapbox://styles/yourmapboxstyle\", \"modules\": { \"exportDataBtn\": true }, \"theme\": { \"filterSidePanel\": { \"buttonColorRange\": [ \"#dc7e6d\", \"#69b59d\", \"#c3c356\" ] } }, \"bottomRightButtons\": [ { \"text\": \"hey im a button\", \"url\": \"url\" }, { \"text\": \"hey im a button\", \"url\": \"url\" } ], \"layers\": [ { \"name\": \"layerName\", \"type\": \"notion\", \"url\": \"notionUrl\", \"id\": 0 }, { \"name\": \"GeoJson Data api\", \"type\": \"geojson\", \"url\": \"url\", \"id\": 1 } ] } Success Response: Code : 200 Content : Get a formated dataset Platform Name: For now the only platform supported by the back is notion URL /api/data/{platform_name}/{datasetId} Method GET Success Response: Returns a kepler.gl formated json of the dataset Code : 200 Content : { fields: {}, rows: {} }","title":"Back"},{"location":"back/#backend","text":"","title":"Backend"},{"location":"back/#api-routes","text":"","title":"API Routes"},{"location":"back/#test-backend","text":"URL /api/data/test/ Method GET Success Response: Returns test string Code : 200 Content : test","title":"Test backend"},{"location":"back/#get-the-kepler-configuration","text":"URL /api/conf/kepler Method GET Success Response: Returns a kepler.gl formated json of the dataset Code : 200 Content : { \"version\": \"v1\", \"config\": { \"visState\": {}, \"mapState\": {}, \"mapStyle\": {} } }","title":"Get the kepler configuration"},{"location":"back/#get-the-instance-configuration","text":"URL /api/conf/kepler Method GET Success Response: Returns a kepler.gl formated json of the dataset Code : 200 Content : { \"siteTitle\": \"Instance Name\", \"mapboxToken\": \"mapboxToken\", \"defaultMapLocation\": { \"latitude\": 0, \"longitude\": 0, \"zoom\": 10 }, \"defaultMapBoxStyleUrl\": \"mapbox://styles/yourmapboxstyle\", \"modules\": { \"exportDataBtn\": true }, \"theme\": { \"filterSidePanel\": { \"buttonColorRange\": [ \"#dc7e6d\", \"#69b59d\", \"#c3c356\" ] } }, \"bottomRightButtons\": [ { \"text\": \"hey im a button\", \"url\": \"url\" }, { \"text\": \"hey im a button\", \"url\": \"url\" } ], \"layers\": [ { \"name\": \"layerName\", \"type\": \"notion\", \"url\": \"notionUrl\", \"id\": 0 }, { \"name\": \"GeoJson Data api\", \"type\": \"geojson\", \"url\": \"url\", \"id\": 1 } ] }","title":"Get the instance configuration"},{"location":"back/#update-the-kepler-configuration","text":"URL /api/conf/kepler Method POST Data Constrains The kepler json is created trough the kepler interface body: form-data key: configuration_kepler value: { \"version\": \"v1\", \"config\": { \"visState\": {}, \"mapState\": {}, \"mapStyle\": {} } } Success Response: Code : 200 Content :","title":"Update the kepler configuration"},{"location":"back/#update-the-instance-configuration","text":"URL /api/conf/instance Method POST Data Constrains The kepler json is created trough the kepler interface body: form-data key: configuration_instance value: { \"siteTitle\": \"Instance Name\", \"mapboxToken\": \"mapboxToken\", \"defaultMapLocation\": { \"latitude\": 0, \"longitude\": 0, \"zoom\": 10 }, \"defaultMapBoxStyleUrl\": \"mapbox://styles/yourmapboxstyle\", \"modules\": { \"exportDataBtn\": true }, \"theme\": { \"filterSidePanel\": { \"buttonColorRange\": [ \"#dc7e6d\", \"#69b59d\", \"#c3c356\" ] } }, \"bottomRightButtons\": [ { \"text\": \"hey im a button\", \"url\": \"url\" }, { \"text\": \"hey im a button\", \"url\": \"url\" } ], \"layers\": [ { \"name\": \"layerName\", \"type\": \"notion\", \"url\": \"notionUrl\", \"id\": 0 }, { \"name\": \"GeoJson Data api\", \"type\": \"geojson\", \"url\": \"url\", \"id\": 1 } ] } Success Response: Code : 200 Content :","title":"Update the instance configuration"},{"location":"back/#get-a-formated-dataset","text":"Platform Name: For now the only platform supported by the back is notion URL /api/data/{platform_name}/{datasetId} Method GET Success Response: Returns a kepler.gl formated json of the dataset Code : 200 Content : { fields: {}, rows: {} }","title":"Get a formated dataset"},{"location":"front/","text":"Front Use DatAtlas Kepler custom package DatAtlas needs a custom version of Kepler where a column can have multiple values. This is achieved by using a JSON value. Having an array value represented as a JSON is specific to DatAtlas and may not be fitted for every projects. This is why the custom Kepler cannot be the subject of a GitHub PR, and should stay as a standalone until a consensus on what is an array value in CSV can be. Next sections describe how to deal with this for developing and building DatAtlas. Without modifying the package.json DatAtlas Kepler custom package must be cloned next to the Front folder, in the system where the Front will be built. Then for the Kepler side: cd kepler.gl npm install npm run build And for the Front side: cd ../front/src npm install npm link ../../kepler.gl # may need sudo npm run build # or npm start By modifying the package.json This implies pushing a different package.json than the one actually versioned and should be the result of a team decision. Several solutions there : The Kepler custom package must be built and published to NPM with a different name (or under a @datatlas scope), and the dependency should refer to this NPM package. The least easy to maintain but the more robust. The Kepler custom package must be built and pushed (dist/ folder included) to Github, then the simplified Github URL format can be used as the dependency version : \"kepler.gl\": \"datatlas-erasme/kepler.gl\", see on NPM doc . Maybe the easiest to do but implies pushing the dist/ folder. Similar to the link solution, the Kepler custom package must be cloned next to the Front folder, in the system where the Front folder will be built, then the dependency can point to this folder : \"kepler.gl\": \"../../kepler.gl\", see on NPM doc . Not great, every developers and build envs must have the same folder structure...","title":"Front"},{"location":"front/#front","text":"","title":"Front"},{"location":"front/#use-datatlas-kepler-custom-package","text":"DatAtlas needs a custom version of Kepler where a column can have multiple values. This is achieved by using a JSON value. Having an array value represented as a JSON is specific to DatAtlas and may not be fitted for every projects. This is why the custom Kepler cannot be the subject of a GitHub PR, and should stay as a standalone until a consensus on what is an array value in CSV can be. Next sections describe how to deal with this for developing and building DatAtlas.","title":"Use DatAtlas Kepler custom package"},{"location":"front/#without-modifying-the-packagejson","text":"DatAtlas Kepler custom package must be cloned next to the Front folder, in the system where the Front will be built. Then for the Kepler side: cd kepler.gl npm install npm run build And for the Front side: cd ../front/src npm install npm link ../../kepler.gl # may need sudo npm run build # or npm start","title":"Without modifying the package.json"},{"location":"front/#by-modifying-the-packagejson","text":"This implies pushing a different package.json than the one actually versioned and should be the result of a team decision. Several solutions there : The Kepler custom package must be built and published to NPM with a different name (or under a @datatlas scope), and the dependency should refer to this NPM package. The least easy to maintain but the more robust. The Kepler custom package must be built and pushed (dist/ folder included) to Github, then the simplified Github URL format can be used as the dependency version : \"kepler.gl\": \"datatlas-erasme/kepler.gl\", see on NPM doc . Maybe the easiest to do but implies pushing the dist/ folder. Similar to the link solution, the Kepler custom package must be cloned next to the Front folder, in the system where the Front folder will be built, then the dependency can point to this folder : \"kepler.gl\": \"../../kepler.gl\", see on NPM doc . Not great, every developers and build envs must have the same folder structure...","title":"By modifying the package.json"}]}